>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 3rd Project Syspro <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Aristi Papastavrou
AM: 1115201800154

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Compiling Options  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

~ Για να φτιάξετε νέο input File με records αλλά ταυτόχρονα να κάνετε και compile τα files του προγράμματος, αρκεί να γράψετε στο terminal: make script NUM_FILES_PER_DIR=x
όπου x o αριθμός αρχείων ανά directory.

~Αλλιώς αν θέλετε να χρησιμοποιήστε το ήδη υπάρχον input file, απλά γράψτε στο terminal: make

Eάν θέλετε απλά να φτιάξετε το input_file γράψτε: bash ./create_infiles.sh input_dir/inputFile.txt input_dir2 numfiles

Για την εκτέλεση του προγράμματος πληκτρολογήστε: ./travelMonitorClient -m 3 -b 100 -c 2 -s 1000 -i input_dir -t 3
Εάν θέλετε να το τρέξετε με valgrind : valgrind --leak-check=full --show-leak-kinds=all ./travelMonitorClient -m 3 -b 100 -c 8 -s 1000 -i input_dir -t 3 (αντικαθιστώντας με τις 
τιμές που θέλετα κάθε φορά)

Έχω φτιάξει ένα instructions.txt το οποίο μπορείτε να τροφοδοτήσετε στην κλήση του προγράμματος προκειμένου να σας παράξει output.
Έχω καλέσει όλα τα queries πλην του /addVaccinationRecords country όπου ο χρήστης πρέπει να φορτώσει ένα file στο κατάλληλο dir και μετά να την καλέσει.
Για να το κάνετε αυτό απλά γραψτε στο terminal: valgrind --leak-check=full --show-leak-kinds=all --trace-children=yes ./travelMonitorClient -m 3 -b 100 -c 2 -s 1000 -i input_dir -t 3 < instructions.txt

Για διαγραφή των εκτελέσιμων πληκτρλογήστε: make clean

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NOTES  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Έχουν υλοποιηθεί όλα τα ζητούμενα της εκφώνησης.Παρόλα αυτά το query /travelRequest citizenID date countryFrom countryTo virusName έχει κάποια συμπεριφορά που πότε του προκαλεί segmentation fault πότε όχι. Παρόλα αυτά αν τρέξετε την εργασία με την εντολή για valgrind (valgrind --leak-check=full --show-leak-kinds=all ./travelMonitor -m 3 -b 100 -c 8 -s 1000 -i input_dir -t 3) τρέχει κανονικά χωρις κανενα προβλημα.Δεν καταφερα να βρω και λογω ελλειψης χρονου τι μπορει να προκαλει αυτη την συμπεριφορα μιας και στην 2η εργασία δεν εντοπισα τετοιο πρβλημα, και το valgrind το τρεχει κανονικα το προγραμμα χωρις να εμφανιζει errors.Τα υπολοιπα queries + functions λειτουργουν κανονικα και χωρις το valgrind.
Οποτε προκειμένου να μην σκασει η εργασια και να μπορεσετε να δειτε το output όλων των queries κανονικα,τρεχτε την εργασια με valgrind --leak-check=full --show-leak-kinds=all --trace-children=yes ./travelMonitorClient -m 3 -b 100 -c 2 -s 1000 -i input_dir -t 3

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Protocols <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Η εργασία έχει υλοποιηθει με βάση το μοντέλο one client, many servers. Ο client να ειναι το TravelMonitor και οι servers τα monitors.Η όλη διαδικασια κατασκευης των monitors ειναι ίδια με 
της 2ης εργασίας οποτε παραθέτω και το README 2 για επιπλεον εξηγησεις.Σε πρωτη φαση ο travelMonitor ζητά από τους n_monitors να πραγματοποιησουν συνδεση (μεσω της connect) προκειμενου να ανταλλαξουν δεδομενα.Αφου ο καθε server-monitor κανει accept το αιτημα, προχωραμε σε ενα while loop οπου μεσω select βρισκει ο travel monitor απο ποιον server δεχεται bloom filters και εν συνεχεια τα αποθηεκευει στην "βαση δεδομενων" του.Αφου μας στειλουν ολοι οι server μηνυμα οτι τελειωσαν την αποστολη bloom filters, κλεινουμε τα connections.Γενικα με βάση πηγες στο internet για socket-programming συνίσταται να κλεινουμε τις συνδεσεις και μετα να δημιουργουμε ξανα οπου χρειαζεται. Αυτο βοηθαει στο να μην "ξεμεινουμε" απο socket-fds.
Οταν τελειωσει η διαδικασια ανταλλαγης bloom filter, περναμε στην 2η φαση του προγραμματος μας, οπου κανουμε handle τα queries.Σε αυτη την φαση λοιπον, οι servers κανουν ξεχωριστα bind και listen ο καθενας στον client προκειμενου να δεχθουν τα user-input queries. Παλι σε while loop ο travel Monitor βρισκει ποιο query πρεπει να εκτελεσει και αναλογως στελνει το αντιστοιχο μηνυμα στους server απο τους οποιους και περιμενει απαντηση την οποια λαμβανει μεσω της select.Οταν ο user πατησει /exit καλει τον Destructor της βασης που ελευθερωνει τα διαφορα structures, περιμενει να "τελειωσουν" και να κανουν exit τα monitors, και τελος κλεινει τις συνδεσεις.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Τhreads <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Σε πρωτη φάση γεμιζουμε όλο το cyclic buffer με όσες χώρες χωράνε στο size του.Στην συνεχεια δημιουργουμε ενα thread pool όπου με την χρηση mutexes και conditional variables ο 
producer έχει μονο το δικαιωμα να "πειραξει" τα δεδομενα του cyclic buffer.Μονο ένας consumer έχει καθε φορα την δυνατοτητα να παρει αρχειο από το cyclic buffer αφου τα threads παραμενουν 
κλειδωμενα μεχρι να τελειωσει ο consumer το extraction.Εαν δουμε σε λουπα ότι το buffer μας ειναι αδειο τότε ενώ τα threads παραμενουν κλειδωμενα στον is_empty ελεγχο μας, γεμιζουμε τον 
buffer με τις εναπομειναντες χωρες.Για καθε χωρα που ανακτα ο consumer καλουμε και την αντιστοιχη συναρτησ που προσθετει τα records στην βαση δεδομενων των monitors και ύστερα στελνει τα 
bloom filters στον travel monitor.

Μολις τα monitors λάβουν εντολη exit τότε καλούμε την destroy_threads όπου κάνει join τα numthreads που ειχαμe δημιουργησει και ελευθερωνει τα thread mutexes/conditional variables. 
Ο αλγόριθμος του circular buffer είναι αυτός που παρουσιάζει η κυρία Μέμα στος διαφάνειες της, http://cgi.di.uoa.gr/~mema/courses/k24/lectures/topic6-Threads.pdf
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Queries <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  
Δεν εχει γινει καμια αλλαγη στον αλγοριθμο των queries. Μπορειτε να βρειτε τις αναλογες εξηγησεις στο README2.txt 